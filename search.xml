<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>工单项目</title>
      <link href="2021/03/28/%E5%B7%A5%E5%8D%95%E9%A1%B9%E7%9B%AE/"/>
      <url>2021/03/28/%E5%B7%A5%E5%8D%95%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/river.png" alt="cover"><br>一、工单项目理解<br>工单系统拥有用户，先实现用户登录、修改用户权限姓名等…然后进行工单的添加，审核人和私信聊天</p><p>二、用户的创建</p><p>model.py:</p><pre><code class="js">class Base(models.Model):    # 创建时间    create_time = models.DateTimeField(default=timezone.now, null=True)    class Meta:        abstract = True# 用户类class User(Base):    username = models.CharField(max_length=100, unique=True,verbose_name=&#39;用户名&#39;)    password = models.CharField(max_length=200,verbose_name=&#39;密码&#39;)    phone = models.CharField(max_length=100, unique=True, null=True,verbose_name=&#39;电话&#39;)    level = models.IntegerField(default=1,verbose_name=&#39;用户等级&#39;)    sf = models.BooleanField(default=False,verbose_name=&#39;三方登录&#39;)    sf_type = models.CharField(max_length=20, verbose_name=&quot;三方类型&quot;, null=True)    sf_id = models.IntegerField(null=True,verbose_name=&#39;三方登录id&#39;)    class Meta:        db_table = &quot;user&quot;</code></pre><p>实现用户名怎删改查</p><pre><code class="js">class GendertUUid(APIView):    def get(self, request):        &quot;&quot;&quot;        返回验证码图片        :param request:        :return:        &quot;&quot;&quot;        #  uuid        uuid = request.GET.get(&#39;id&#39;)        # 生成随机数        random_num = random_str()        # 生成图片        image = make_verify_image(random_num, uuid)        # 返回图片        return HttpResponse(image, content_type=&#39;image/jpeg&#39;)class Refresh(APIView):    def post(self, request):        username = request.data.get(&#39;username&#39;)        password = request.data.get(&#39;password&#39;)        phone = request.data.get(&#39;phone&#39;)        # 用户输入的验证码        crossing = request.data.get(&#39;crossing&#39;)        print(crossing)        # uuid        uuid = request.data.get(&#39;uuid&#39;)        # redis存储的验证码        redis_uuid = str(r.get(uuid))        print(redis_uuid)        # 验证手机号        user_phone = User.objects.filter(phone=phone).first()        if user_phone:            return Response(&#123;&#39;msg&#39;: &#39;手机号已被绑定,请重新输入!&#39;, &#39;code&#39;: 10006&#125;)        #  验证用户名不能为空        if username == &#39;&#39;:            return Response(&#123;&#39;msg&#39;: &#39;用户名不能为空!&#39;, &#39;code&#39;: 10004&#125;)        #  正则验证手机号格式        new_phone = re.match(&#39;^1[3-9]&#123;1&#125;[0-9]&#123;9&#125;$&#39;, phone)        if new_phone:            pass        else:            return Response(&#123;&#39;msg&#39;: &#39;手机号格式不符合!&#39;, &#39;code&#39;: 10005&#125;)        # 与redis的验证码作比较        if crossing == redis_uuid:            user = User.objects.filter(username=username).first()            #  验证用户名是否重复            if user:                return Response(&#123;&#39;msg&#39;: &#39;用户名重复,请重新输入!&#39;, &#39;code&#39;: 10002&#125;)            else:                #  注册                User.objects.create(                    username=username,                    password=password,                    phone=phone                )                return Response(&#123;&#39;msg&#39;: &#39;注册成功!&#39;, &#39;code&#39;: 10000&#125;)        else:            return Response(&#123;&#39;msg&#39;: &#39;验证码输入错误,请重新输入!&#39;, &#39;code&#39;: 10001&#125;)class SelectUser(APIView):    def get(self, request):        username = request.GET.get(&#39;username&#39;)        if username:            queryset = User.objects.filter(username=username)            ser = UserSer1(queryset, many=True)            return Response(ser.data)        else:            queryset = User.objects.all()            ser = UserSer1(queryset, many=True)            return Response(ser.data)    def delete(self, request):        id = request.GET.get(&#39;id&#39;)        if id:            User.objects.filter(id=id).delete()            return Response(&#123;&#39;msg&#39;: &#39;删除成功&#39;&#125;)        else:            return Response(&#123;&#39;msg&#39;: &#39;没有该id&#39;&#125;)class PutUser(APIView):    def put(self, request):        username = request.data.get(&#39;username&#39;)        new_username = request.data.get(&#39;new_username&#39;, username)        password = request.data.get(&#39;password&#39;)        phone = request.data.get(&#39;phone&#39;)        data = putUser(username, new_username, password, phone)        print(data)        return Response(data)    </code></pre><p>实现登录输入错误5次不允许登录</p><pre><code class="js">class LoginUser(APIView):    def post(self, request):        username = request.data.get(&#39;username&#39;)        password = request.data.get(&#39;password&#39;)        user = User.objects.filter(username=username, password=password).first()        if user:            #  实现状态保持            payload = &#123;                &#39;exp&#39;: datetime.datetime.utcnow() + datetime.timedelta(hours=10),                &#39;uid&#39;: user.id,            &#125;            token = jwt.encode(payload=payload, key=SECRET_KEY)            return Response(&#123;&#39;msg&#39;: &#39;登录成功&#39;, &#39;code&#39;: 10000, &#39;token&#39;: token, &#39;uid&#39;: user.id, &#39;username&#39;: user.username&#125;)        else:            key = &#39;user_%s&#39; % username            key_black = &#39;user_black&#39;            # 只要黑名单有该用户直接封杀            if r.get(key_black) == key:                return Response(&#123;&#39;msg&#39;: &#39;您的账号已经被封禁1分钟!&#39;, &#39;code&#39;: 44444&#125;)            else:                # 判断用户是否存在                if r.keys(key):                    #  五分钟内出现五次以上                    if int(r.get(key)) &gt;= 5:                        r.set(key, 0)  # 清除该用户次数                        r.set(key_black, key)  # 清除同时加入黑名单                        r.expire(key_black, 60)  # 并且设置封禁时间                        return Response(&#123;&#39;msg&#39;: &#39;您的账号已经被封禁1分钟!&#39;, &#39;code&#39;: 44444&#125;)                    # 小于五次次数 做累加                    else:                        r.incrby(key, 1)                        return Response(&#123;&#39;msg&#39;: &#39;账号或密码输入错,请重新输入!&#39;, &#39;code&#39;: 10004&#125;)                # 不存在则存取                else:                    r.set(key, 1)                    r.expire(key, 30)                    return Response(&#123;&#39;msg&#39;: &#39;账号或密码输入错,请重新输入!&#39;, &#39;code&#39;: 10004&#125;)</code></pre><p>实现三方登录 钉钉、gitee</p><pre><code class="js">class GiteeBack(APIView):    def get(self, request):        code = request.GET.get(&quot;code&quot;, None)        r = requests.post(            &quot;https://gitee.com/oauth/token?grant_type=authorization_code&amp;code=&quot; + code + &quot;&amp;client_id=&quot; + CLIENT_ID + &quot;&amp;redirect_uri=http://127.0.0.1:8000/gitee_back&amp;client_secret=&quot; + CLIENT_SECRET)        # print(r.text)        mess = eval(r.text)        # print(type(mess))        # print(mess[&#39;access_token&#39;])        r = requests.get(&quot;https://gitee.com/api/v5/user?access_token=&quot; + mess[&#39;access_token&#39;])        print(r.text)        res = json.loads(r.text)        user = User.objects.filter(sf_type=&#39;0b001&#39;, sf_id=res[&#39;id&#39;]).first()        if user:            user.username = res[&#39;name&#39;]            user.save()        else:            User.objects.create(username=res[&#39;name&#39;], sf_type=&#39;0b001&#39;, sf_id=res[&#39;id&#39;], password=res[&#39;name&#39;],                                sf=True)        return redirect(&#39;http://127.0.0.1:8080/#/?username=&#123;&#125;&#39;.format(res[&#39;name&#39;]))import hmacimport base64from hashlib import sha256import urllibclass DingBack(View):    def get(self, request):        # 获取code        code = request.GET.get(&quot;code&quot;)        t = time.time()        # 时间戳        timestamp = str((int(round(t * 1000))))        appSecret = APP_SECRET        # 构造签名        signature = base64.b64encode(            hmac.new(appSecret.encode(&#39;utf-8&#39;), timestamp.encode(&#39;utf-8&#39;), digestmod=sha256).digest())        # 请求接口，换取钉钉用户名        payload = &#123;&#39;tmp_auth_code&#39;: code&#125;        headers = &#123;&#39;Content-Type&#39;: &#39;application/json&#39;&#125;        res = requests.post(&#39;https://oapi.dingtalk.com/sns/getuserinfo_bycode?signature=&#39; + urllib.parse.quote(            signature.decode(&quot;utf-8&quot;)) + &quot;&amp;timestamp=&quot; + timestamp + &quot;&amp;accessKey=dingoausbsbnopkbfhhqvt&quot;,                            data=json.dumps(payload), headers=headers)        res_dict = json.loads(res.text)[&#39;user_info&#39;]        print(res_dict[&#39;nick&#39;])        user = User.objects.filter(sf_type=&#39;0b010&#39;, username=res_dict[&#39;nick&#39;]).first()        if user:            user.username = res_dict[&#39;nick&#39;]            user.save()        else:            User.objects.create(username=res_dict[&#39;nick&#39;], sf_type=&#39;0b010&#39;, password=res_dict[&#39;nick&#39;], sf=True)            return redirect(&#39;http://127.0.0.1:8080/#/?username=&#123;&#125;&#39;.format(res_dict[&#39;nick&#39;]))</code></pre><p>添加查询工单名称(利用递归)</p><pre><code class="js">def ca(pid):    # 查询工单里所有与当前审批人对于的数据    queryset = Gongdan.objects.filter(pid=pid)    data = GongdanSer(queryset, many=True).data    # 定义新列表    lis = []    # 循环查询到的数据    for i in data:        # 利用递归无线查询id        i[&#39;x&#39;] = ca(i[&#39;id&#39;])        # 添加到列表中        lis.append(i)    # 返回列表    return lisclass GongdanView(APIView):    def post(self, request):        name = request.data.get(&#39;name&#39;)        pid = request.data.get(&#39;pid&#39;)        # 当前审批人是否存在        if pid:            Gongdan.objects.create(name=name, pid=pid)        else:            Gongdan.objects.create(name=name)        return Response(&#123;&#39;msg&#39;: &#39;添加成功&#39;&#125;)    def get(self, request):        # 查询工单所有数据        queryset = Gongdan.objects.all()        all = GongdanSer(queryset, many=True).data        return Response(&#123;&quot;next&quot;: ca(0), &#39;all&#39;: all&#125;)</code></pre><p>添加查询工单详情并给审核人发送消息</p><pre><code class="js">class QingJiaView(APIView):    def get(self, request):        pid = request.GET.get(&#39;pid&#39;)        # 查询当前审核人的数据        query = Moban.objects(pid=pid).first()        # 返回mb去接收前段数据，mbs为已有的数据        return Response(&#123;&#39;mb&#39;: eval(query.geshi), &#39;mbs&#39;: eval(query.geshi)&#125;)    def put(self, request):  # 添加        pid = request.data.get(&#39;pid&#39;)        geshi = request.data.get(&#39;geshi&#39;)        # 模板添加当前审核人和格式数据        Moban.objects.create(pid=pid, geshi=geshi)        return Response(&#39;ok&#39;)    def post(self, request):  # 修改        uid = request.data.get(&#39;uid&#39;)        # 获取所有审核人        Approved_list = request.data.get(&#39;Approved_list&#39;)        # 判断所有审核人类型如果为int则转换成列表字符串形式        # if type(eval(Approved_list)) == int:        #     Approved_list = str([Approved_list])        qiniuimg = request.data.get(&#39;qiniuimg&#39;)        info = request.data.get(&#39;info&#39;)        data = QinjiaMoban.objects.create(uid=uid, pid=eval(Approved_list)[0], Approved_list=str(Approved_list),                                          info=str(info), qiniuimg=qiniuimg)        App = eval(Approved_list)        text = &#39;您收到了一条审核工单&#39;        if type(App[0]) == list:            for i in App[0]:                Qingjia_gl.objects.create(gid=data.id, pid=i)                r.hset(&#39;user&#123;&#125;&#39;.format(i), &#39;message%s&#39; % data.id,                       str(&#123;&#39;id&#39;:data.id,&quot;text&quot;: text,  &quot;uid&quot;: i, &quot;read&quot;: 0, &quot;withdraw&quot;: 0,&#39;img&#39;:qiniuimg&#125;))        else:            Qingjia_gl.objects.create(gid=data.id, pid=App[0])            r.hset(&#39;user&#123;&#125;&#39;.format(App[0]), &#39;message%s&#39; % data.id,                   str(&#123;&#39;id&#39;:data.id,&quot;text&quot;: text, &quot;uid&quot;: App[0], &quot;read&quot;: 0, &quot;withdraw&quot;: 0,&#39;img&#39;:qiniuimg&#125;))        cli = MongoClient()        db = cli[&#39;text&#39;]        tbl = db[&#39;text&#39;]        # 过期删除数据库120s        tbl.create_index([(&#39;updated&#39;,int(data.id))], expireAfterSeconds=20)        tbl.insert_one(&#123;&#39;id&#39;: int(data.id), &#39;updated&#39;: datetime.datetime.utcnow()&#125;)  # 将数据存入mongo数据库        return Response(&#123;&#39;data&#39;: &#39;ok&#39;&#125;)</code></pre><p>分装添加工单的并审和串审</p><pre><code class="js">class Factory:    def __init__(self, gid, start):        self.qingjia = QinjiaMoban.objects.filter(id=gid)        self.qingjia_info = self.qingjia.first()        self.pid = eval(self.qingjia_info.pid)        # 关联外键gid        self.gid = gid        # 状态        self.start = start    # 串审    def Chuan(self, start):        # 判断状态不是拒绝时        if start != 2:            # 清空当前申请信息            Qingjia_gl.objects.filter(gid=self.gid).delete()            # 新建申请信息            Qingjia_gl.objects.create(gid=self.gid, pid=self.pid)            self.qingjia.update(pid=str(self.pid), start=3)        else:            # 清空当前申请信息            Qingjia_gl.objects.filter(gid=self.gid).delete()            Qingjia_gl.objects.create(gid=self.gid, pid=self.pid)            self.qingjia.update(pid=str(self.pid), start=2)    # 并审    def Bing(self, start):        if start != 2:            # 清空当前申请信息            Qingjia_gl.objects.filter(gid=self.gid).delete()            for i in self.pid:                # 新建申请信息                Qingjia_gl.objects.create(gid=self.gid, pid=i)            self.qingjia.update(pid=self.pid, start=3)        else:            # 清空当前申请信息            Qingjia_gl.objects.filter(gid=self.gid).delete()            for i in self.pid:                # 新建申请信息                Qingjia_gl.objects.create(gid=self.gid, pid=i)            self.qingjia.update(pid=self.pid, start=2)    def Zs(self):        # 执行审批逻辑        # 根据值获取下标        next_index = eval(self.qingjia_info.Approved_list).index(self.pid)        # 判断状态不是拒绝时        if self.start != 2:            # 审核人列表下标加1            next_index += 1            # 如果审核人为最后一个人的时候同意修改pid为None状态为同意            if next_index == len(eval(self.qingjia_info.Approved_list)):                self.qingjia.update(pid=None, start=1)                Qingjia_gl.objects.filter(gid=self.gid).delete()                # 结束判断                return            # 根据获取的下标获取值            next_pid = eval(self.qingjia_info.Approved_list)[next_index]            print(&#39;pid&#39;, next_pid)            # 修改当前审核人为获取的下标值            self.qingjia.update(pid=next_pid, start=3)            self.pid = next_pid            if type(next_pid) == list:                self.Bing(self.start)            else:                self.Chuan(self.start)        else:            if next_index == 0:                self.qingjia.update(pid=None, start=2)                Qingjia_gl.objects.filter(gid=self.qingjia_info.id).delete()                return            next_index -= 1            next_pid = eval(self.qingjia_info.Approved_list)[next_index]            self.qingjia.update(pid=next_pid, start=3)            self.pid = next_pid            if type(next_pid) == list:                self.Bing(self.start)            else:                self.Chuan(self.start)</code></pre><p>显示请假展示等…(分装、不分装)</p><pre><code class="js">class QingjiaZhanshi(APIView):    def get(self, request):        uid = request.GET.get(&#39;uid&#39;)        # 获取请假模板uid对应的数据        queryset = QinjiaMoban.objects.filter(uid=uid)        # 字典返回值        zs = &#123;0: &#39;未审批&#39;, 1: &#39;审批通过&#39;, 2: &#39;审批未通过&#39;, 3: &#39;审批中&#39;&#125;        data = []        for i in queryset:            # 查询User表返回username            user_info = User.objects.get(id=i.uid)            js = &#123;&#125;            # 申请人            js[&#39;username&#39;] = user_info.username            # 审批人列表            js[&#39;Approved_list&#39;] = []            # 状态是否审批            js[&#39;start&#39;] = zs[i.start]            # 凭证图片            js[&#39;qiniuimg&#39;] = i.qiniuimg            # 对应请假日期原因等            js[&#39;info&#39;] = eval(i.info)            # 循环查询数据中的审批人列表            for j in eval(i.Approved_list):                # 如果审批人的类型为list                if type(j) == list:                    # 审批人展示                    js[&#39;Approved_list&#39;].append(                        [User.objects.get(id=k).username for k in j]                    )                else:                    js[&#39;Approved_list&#39;].append(User.objects.get(id=j).username)            # 如果当然审批人存在            if i.pid:                e_pid = eval(i.pid)                # 如果当然审批人的类型为list                if type(e_pid) == list:                    # 当前审批人姓名添加列表                    js[&#39;pid_name&#39;] = [User.objects.get(id=k).username for k in e_pid]                # 如果类型不为list                else:                    # 当前单个审批人添加列表                    js[&#39;pid_name&#39;] = User.objects.get(id=e_pid).username                # 根据值查询下标赋值                js[&#39;f_index&#39;] = js[&#39;Approved_list&#39;].index(js[&#39;pid_name&#39;])            else:                js[&#39;f_index&#39;] = None            # 如果状态为审批未通过            if i.start == 2:                # 拒绝原因修改赋值                js[&#39;refuse&#39;] = i.refuse            else:                # 否则为None                js[&#39;refuse&#39;] = None            # 循环的数据添加到列表            data.append(js)        return Response(data)    def put(self, request):        # 获取请假模板的id查询        id = request.data.get(&#39;id&#39;)        # 审批为通过拒绝1为通过2为拒绝        start = request.data.get(&#39;start&#39;)        # 审批拒绝原因        refuse = request.data.get(&#39;refuse&#39;, None)        # 查询请假模板对应id的数据        qingjia = QinjiaMoban.objects.filter(id=id)        # qingjia_info = qingjia.first()        # 如果拒绝原因存在        if refuse:            # 则修改拒绝原因            qingjia.update(refuse=refuse)        ccs = Factory(gid=id, start=start)        ccs.Zs()        # 如果状态不为拒绝(2)        # if start != 2:        #     # 赋值pid转换类型        #     pid = eval(qingjia_info.pid)        #     # a_list定义的列表转换Approved_list为list的类型        #     a_list = eval(qingjia_info.Approved_list)        #     # 当前下标的下标+1为当前审核人的下标        #     next_index = a_list.index(pid) + 1        #     # 如果当前下标+1后的长度等于最后一个值的时候        #     if next_index == len(a_list):        #         # 修改状态为审核通过        #         qingjia.update(start=1)        #         # 当前审核人为空        #         qingjia.update(pid=None)        #     else:        #         # 如果不为最后一个值的时候状态为正在审核中        #         qingjia.update(start=3)        #         # 修改pid的值为当前审核人的下标        #         qingjia.update(pid=a_list[next_index])        # else:        #     pid = qingjia_info.pid        #     # 赋值a_list为转换为后的审核人列表(list)        #     a_list = eval(qingjia_info.Approved_list)        #     # pid_index当前审核人下标        #     pid_index = a_list.index(eval(pid))        #     # 如果下标为0拒绝        #     if pid_index == 0:        #         # 赋值pid为空        #         qingjia.update(pid=None)        #         # 状态为审核未通过        #         qingjia.update(start=2)        #     else:        #         # 如果下标不为0拒绝则回退下标减1        #         qingjia.update(pid=a_list[pid_index - 1])        #         # 修改状态为审核中        #         qingjia.update(start=3)        return Response(&#123;&#39;msg&#39;: &#39;审批完成&#39;&#125;)    def post(self, request):        pid = request.data.get(&#39;pid&#39;)        query = Qingjia_gl.objects.filter(pid=pid)        for i in query:            print(i.gid)        data = [QingJiaInfoSer(i.gid) for i in query]        Qingjia_gl.objects.filter(pid=pid, read=False).update(read=True)        # # 获取当前审核人pid        # pid = request.data.get(&#39;pid&#39;)        # # 获取全部数据        # query = QinjiaMoban.objects.all()        # # 定义空列表        # data = []        # zs = &#123;0: &#39;未审批&#39;, 1: &#39;审批通过&#39;, 2: &#39;审批未通过&#39;,3: &#39;审批中&#39;&#125;        # # 循环query数据        # for i in query:        #     # 如果当前审核人存在        #     if i.pid:        #         # 转换赋值        #         i_pid = eval(i.pid)        #     else:        #         #跳过当前循环继续下一次循环        #         continue        #     # 如果赋值的pid类型为list        #     if type(i_pid)==list:        #         #又如果pid在在列表中        #         if not pid in eval(i.pid):        #             # 跳过当前循环继续下一次循环        #             continue        #     # if not i.pid == i_pid:        #     #     continue        #     # 查询User表返回username        #     user_info = User.objects.get(id=i.uid)        #     js = &#123;&#125;        #     js[&#39;id&#39;] = i.id        #     js[&#39;name&#39;] = user_info.username        #     js[&#39;start&#39;] = zs[i.start]        #     js[&#39;info&#39;] = eval(i.info)        #        #     data.append(js)        return Response(data)</code></pre><p>实现消息的互通展示等…</p><pre><code class="js">class MessageView(APIView):    def get(self, request):        uid = request.GET.get(&#39;uid&#39;)        zt = &#123;0: &#39;未读&#39;, 1: &#39;已读&#39;&#125;        # 获取未读数据数量        query = Cate.objects.filter(pid=uid).order_by(&#39;create&#39;)        ids_0 = []        ids_1 = []        for i in query:            if i.uid not in ids_0 and i.uid not in ids_1:                if i.read == 0:                    ids_0.append(i.uid)                else:                    ids_1.append(i.uid)        user_info_list = []        for i in ids_0:            js = &#123;&#125;            user = User.objects.get(id=i)            js[&#39;username&#39;] = user.username            js[&#39;id&#39;] = user.id            js[&#39;msg_count&#39;] = len(Cate.objects.filter(uid=i, pid=uid, read=False))            user_info_list.append(js)        for i in ids_1:            js = &#123;&#125;            user = User.objects.get(id=i)            js[&#39;username&#39;] = user.username            js[&#39;id&#39;] = user.id            js[&#39;msg_count&#39;] = len(Cate.objects.filter(uid=i, pid=uid, read=False))            user_info_list.append(js)        count = Cate.objects.filter(pid=uid, read=False)        return Response(&#123;&#39;count&#39;: len(count), &#39;info&#39;: user_info_list&#125;)    def post(self,request):        pass    def put(self, request):        uid = request.data.get(&#39;uid&#39;)        pid = request.data.get(&#39;pid&#39;)        Cate.objects.filter(pid=uid, uid=pid).update(read=True)        return Response(&#39;ok&#39;)from qiniu import Authfrom my.settings import AccessKey, SecretKeydef qiniu_token():    # 定义密钥    qn = Auth(&#39;c6WPZAJYWKjtl-A0d9lnx0NeHpXtVUnPFKPM1er5&#39;, &#39;fVGVpKAjM2PHUaEoQ5EnDcO6krasp95rRGFJMrFZ&#39;)    # 指定上传空间, 返回token值    token = qn.upload_token(&#39;sbzjj&#39;)    return tokenfrom django.views import Viewfrom django.http import JsonResponseclass UpTokenView(View):    def get(self, request):        return JsonResponse(&#123;&#39;token&#39;: qiniu_token()&#125;)class CateView(APIView):    def get(self, request):        uid = request.GET.get(&#39;uid&#39;)        c = r.hgetall(&#39;user&#123;&#125;&#39;.format(uid))        reads = &#123;0:&#39;未读&#39;,1:&#39;已读&#39;&#125;        list1 = []        length = 0        for key, values in c.items():            i = eval(values)            i[&#39;read&#39;] = reads[i[&#39;read&#39;]]            list1.append(i)            if i[&#39;read&#39;] == &#39;未读&#39;:                length += 1        return Response(&#123;&#39;message&#39;: list1, &#39;count&#39;: length&#125;)    def put(self, request):        uid = request.GET.get(&#39;uid&#39;)        c = r.hgetall(&#39;user&#123;&#125;&#39;.format(uid))        for key, values in c.items():            i = eval(values)            r.hset(&#39;user%s&#39; % uid, key, str(&#123;&#39;id&#39;:i[&#39;id&#39;],&quot;text&quot;: i[&#39;text&#39;], &quot;img&quot;: i[&#39;img&#39;], &quot;uid&quot;: i[&#39;uid&#39;], &quot;read&quot;: 1, &quot;withdraw&quot;: 0&#125;))        return Response(&#123;&#39;msg&#39;:&#39;ok&#39;&#125;)    def post(self, request):        cid = request.data.get(&#39;cid&#39;)        uid = request.data.get(&#39;uid&#39;)        c = r.hgetall(&#39;user&#123;&#125;&#39;.format(uid))        cli = MongoClient()        db = cli[&#39;text&#39;]        tbl = db[&#39;text&#39;]        for key, values in c.items():            i = eval(values)            zs=tbl.find(&#123;&#39;id&#39;:cid&#125;)            print(zs)            if tbl in zs:                if cid == i[&#39;id&#39;]:                    r.hset(&#39;user%s&#39; % uid, key, str(&#123;&#39;id&#39;:i[&#39;id&#39;],&quot;text&quot;: i[&#39;text&#39;], &quot;img&quot;: i[&#39;img&#39;], &quot;uid&quot;: i[&#39;uid&#39;], &quot;read&quot;: i[&#39;read&#39;], &quot;withdraw&quot;: 1&#125;))                    return Response(&#123;&#39;msg&#39;: &#39;已撤回&#39;&#125;)            else:                return Response(&#123;&#39;msg&#39;: &#39;超过2分钟无法撤回&#39;&#125;)class ChatView(APIView):    def post(self, request):        uid = request.data.get(&#39;uid&#39;)        pid = request.data.get(&#39;pid&#39;)        text = request.data.get(&#39;text&#39;)        img = request.data.get(&#39;img&#39;)        info = Cate.objects.create(uid=uid, pid=pid, text=text,img=img)        r.set(&#39;&#123;&#125;chexiao&#39;.format(info.id), &#39;hh&#39;, ex=120)        return Response(&#123;&#39;msg&#39;:&#39;ok&#39;&#125;)    def get(self, request):        uid = request.GET.get(&#39;uid&#39;)        # 获取未读数据数量        query = Cate.objects.filter(pid=uid).order_by(&#39;create&#39;)        ids_0 = []        ids_1 = []        for i in query:            if i.uid not in ids_0 and i.uid not in ids_1:                if i.read == 0:                    ids_0.append(i.uid)                else:                    ids_1.append(i.uid)        user_info_list = []        for i in ids_0:            js = &#123;&#125;            user = User.objects.get(id=i)            js[&#39;username&#39;] = user.username            js[&#39;id&#39;] = user.id            js[&#39;msg_count&#39;] = len(Cate.objects.filter(uid=i, pid=uid, read=False))            user_info_list.append(js)        for i in ids_1:            js = &#123;&#125;            user = User.objects.get(id=i)            js[&#39;username&#39;] = user.username            js[&#39;id&#39;] = user.id            js[&#39;msg_count&#39;] = len(Cate.objects.filter(uid=i, pid=uid, read=False))            user_info_list.append(js)        count = Cate.objects.filter(pid=uid, read=False)        return Response(&#123;&#39;count&#39;: len(count), &#39;info&#39;: user_info_list&#125;)    def put(self,request):        uid = request.data.get(&#39;uid&#39;)        pid = request.data.get(&#39;pid&#39;)        Cate.objects.filter(pid=uid, uid=pid).update(read=1)        return Response(&#39;ok&#39;)    def delete(self, request):        id = request.GET.get(&#39;id&#39;)        r = redis.Redis(decode_responses=True)        yz = r.get(&#39;&#123;&#125;chexiao&#39;.format(id))        if yz:            Cate.objects.get(id=id).delete()            return Response(&#123;&#39;code&#39;: &#39;200&#39;&#125;)        return Response(&#123;&#39;code&#39;: &#39;400&#39;&#125;)</code></pre><p>最后使用websocket实现代码的展示</p><pre><code class="js"># 导入websocket装饰器@accept_websocketdef msg_websocket(request, pid, uid):    if request.is_websocket():        while True:            # 刷新间隔为1秒            time.sleep(1)            msg_query = Cate.objects.filter(uid=pid, pid=uid)            to_msg_query = Cate.objects.filter(uid=uid, pid=pid)            data = []            for i in msg_query:                js = &#123;&#125;                js[&#39;id&#39;] = i.id                js[&#39;text&#39;] = i.text                js[&#39;uid&#39;] = i.uid                js[&#39;create&#39;] = i.create                js[&#39;img&#39;] = i.img                # print(i.img)                data.append(js)            for i in to_msg_query:                js = &#123;&#125;                js[&#39;id&#39;] = i.id                js[&#39;text&#39;] = i.text                js[&#39;uid&#39;] = i.uid                js[&#39;create&#39;] = i.create                js[&#39;img&#39;] = i.img                # print(i.img)                data.append(js)            data = sorted(data, key=lambda x: x[&#39;create&#39;])            for i in data:                del i[&#39;create&#39;]            request.websocket.send(json.dumps(&#123;&#39;data&#39;:data&#125;))</code></pre>]]></content>
      
      
      <categories>
          
          <category> python&amp;vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工单项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Celery</title>
      <link href="2021/03/21/Celery/"/>
      <url>2021/03/21/Celery/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/tree.png" alt="cover"><br>一、安装celery<br>    pip install celery</p><p>二、创建一个任务文件task.py</p><pre><code class="js">from celery.task import task# 自定义要执行的task任务@taskdef print_test():    print(&quot;gaolei&quot;)    return &#39;hello celery&#39;</code></pre><p>三、配置settings.py文件</p><pre><code class="js">CELERY_BROKER_URL = &#39;redis://localhost:6379/&#39;CELERY_RESULT_BACKEND = &#39;redis://localhost:6379/&#39;CELERY_RESULT_SERIALIZER = &#39;json&#39;</code></pre><p>四、在settings.py同级目录创建celery.py</p><pre><code class="js">from __future__ import absolute_import, unicode_literalsimport osfrom celery import Celery# 设置环境变量os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;mydjango.settings&#39;)# 注册Celery的APPapp = Celery(&#39;mydjango&#39;)# 绑定配置文件app.config_from_object(&#39;django.conf:settings&#39;, namespace=&#39;CELERY&#39;)# 自动发现各个app下的tasks.py文件app.autodiscover_tasks()</code></pre><p>五、修改settings.py同级目录的init.py文件</p><pre><code class="js">from __future__ import absolute_import, unicode_literalsfrom .celery import app as celery_app#导包import pymysql#初始化pymysql.install_as_MySQLdb()__all__ = [&#39;celery_app&#39;]</code></pre><p>六、通过view进行在线调用</p><pre><code class="js">from user import tasksdef ctest(request,*args,**kwargs):    res=tasks.print_test.delay()    #任务逻辑    return JsonResponse(&#123;&#39;status&#39;:&#39;successful&#39;,&#39;task_id&#39;:res.task_id&#125;)</code></pre><p>七、在manage.py的目录下启动celery服务</p><pre><code>celery worker -A mydjango -l info -P eventlet</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Celery来实现异步任务队列以及定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七牛云文件上传</title>
      <link href="2021/03/10/%E4%B8%83%E7%89%9B%E4%BA%91%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>2021/03/10/%E4%B8%83%E7%89%9B%E4%BA%91%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/tree.png" alt="cover"></p><h2 id="七牛云存储"><a href="#七牛云存储" class="headerlink" title="七牛云存储"></a>七牛云存储</h2><h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><p>1、到七牛官网：<a href="https://www.qiniu.com/%E3%80%82%E5%88%9B%E5%BB%BA%E8%B4%A6%E5%8F%B7%E3%80%82%E7%84%B6%E5%90%8E%E5%88%B0%E4%B8%AA%E4%BA%BA%E9%9D%A2%E6%9D%BF-&gt;%E7%A7%98%E9%92%A5%E7%AE%A1%E7%90%86%E5%A4%84%E8%8E%B7%E5%8F%96access_key%E5%92%8Csecret_key%E3%80%82">https://www.qiniu.com/。创建账号。然后到个人面板-&gt;秘钥管理处获取access_key和secret_key。</a> </p><p>2、创建空间，可以选择华北区等。 </p><h4 id="一、安装包"><a href="#一、安装包" class="headerlink" title="一、安装包"></a>一、安装包</h4><pre><code>pip install qiniu</code></pre><h4 id="二、后端"><a href="#二、后端" class="headerlink" title="二、后端"></a>二、后端</h4><p>1、 创建一个获取token的url</p><pre><code class="js">--------上传AccessKey和SecretKey---------from qiniu import Authfrom .settings import AccessKey,SecretKeydef qiniu_token():    # 定义密钥    qn = Auth(AccessKey, SecretKey)    # 指定上传空间, 返回token值    token = qn.upload_token(&#39;sbzjj&#39;)    return token</code></pre><pre><code class="js">from django.views import Viewfrom django.http import JsonResponseclass UpTokenView(View):    def get(self, request):        return JsonResponse(&#123;&#39;token&#39;: qiniu_token()&#125;)</code></pre><p>二、前段</p><pre><code class="js">    &lt;template&gt;  &lt;div&gt;      &lt;p style=&quot;text-align: center;&quot;&gt;&lt;input type=&quot;file&quot; @change=&quot;upload_qiniu&quot;&gt;&lt;/p&gt;          &lt;p v-if=&quot;img_url&quot; style=&quot;text-align: center;&quot;&gt;&lt;img :src=&quot;img_url&quot; alt=&quot;&quot; style=&quot;width: 200px; height: 200px; border-radius:50%;&quot;&gt;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data () &#123;    return &#123;          img_url: &#39;&#39;,          // 七牛去上传凭证          uptoken: &#39;&#39;,    &#125;;  &#125;,  methods: &#123;         // 获取uptoken    get_uptoken() &#123;        this.$axios.get(&#39;uptoken/&#39;).then(res=&gt;&#123;            this.uptoken = res.data.token        &#125;)    &#125;,    // 七牛云上传    upload_qiniu(e) &#123;        // 获取文件对象        let file = e.target.files[0]        // 声明参数        let form_data = new FormData()        // 将上传凭证添加参数        form_data.append(&#39;token&#39;, this.uptoken)        // 添加图片        form_data.append(&#39;file&#39;, file)        // 定制化axios  不携带cookie上传        const axios_qiniu = this.$axios.create(&#123;withCredentials:false&#125;)        // 发送请求        axios_qiniu(&#123;            method: &#39;post&#39;,            url: &#39;http://up-z1.qiniu.com/&#39;,            data: form_data,            tiemout: 30000,        &#125;).then(res=&gt;&#123;            console.log(res)            this.img_url = &#39;http://qq5jf6dzd.hb-bkt.clouddn.com/&#39; + res.data.key        &#125;)    &#125;  &#125;,  mounted()&#123;    this.get_uptoken()  &#125;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 七牛云文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker操作 容器、镜像 dockerfile</title>
      <link href="2021/02/06/day13/"/>
      <url>2021/02/06/day13/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/lake.png" alt="cover"></p><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>虚拟化操作:把一个操作系统分成多个操作系统</p><p>vmware:过于庞大，太过于慢，但是确实安装出来的虚拟机：<strong>隔离性很好</strong><br>docker：更快，更轻巧，但是隔离性不好</p><h4 id="二、docker安装-CentOS7"><a href="#二、docker安装-CentOS7" class="headerlink" title="二、docker安装-CentOS7"></a>二、docker安装-CentOS7</h4><p>安装必要的⼀些系统⼯具</p><pre><code class="js">yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><p>添加软件源信息</p><pre><code class="js">yum-config-manager --add-repo https://mirrors.aliyun.com/dockerce/linux/centos/docker-ce.repo</code></pre><p>更新并安装Docker-CE</p><pre><code class="js">yum makecache fast yum -y install docker-ce</code></pre><p>开启Docker服务</p><pre><code class="js">service docker start</code></pre><h4 id="二、下载镜像"><a href="#二、下载镜像" class="headerlink" title="二、下载镜像"></a>二、下载镜像</h4><p>下载镜像</p><pre><code class="js">docker pull alpine</code></pre><p>查看所有镜像</p><pre><code class="js">docker images</code></pre><p>启动容器：docker run</p><pre><code class="js">docker run -d -i -t 镜像id /bin/bash</code></pre><p>查看所有运行着的容器：docker ps<br>先进入容器进行配置，配置有关webssh连接的事项</p><pre><code class="js">docker attach 镜像id</code></pre><p>安装ssh</p><pre><code class="js">yum install openssh-server</code></pre><p>生成当前主机的ssh-key</p><pre><code class="js">ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_keyssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_keyssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -Nssh-keygen -t dsa -f /etc/ssh/ssh_host_ed25519_key</code></pre><p>在容器里启动ssh服务，让外界可以连接</p><pre><code class="js">/usr/sbin/sshd</code></pre><h4 id="三、Dockerfile"><a href="#三、Dockerfile" class="headerlink" title="三、Dockerfile"></a>三、Dockerfile</h4><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>在一个空白目录中，建立一个文本文件，并命名为 Dockerfile ：</p><pre><code class="js"> mkdir mynginx cd mynginx touch Dockerfile</code></pre><p>构建dockerfile</p><pre><code class="js">docker build -t nginx:v3...</code></pre><p>docker build 命令进行镜像构建</p><pre><code class="js">docker build [选项] /home/tools/dockerfile</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker操作 容器、镜像 dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直播</title>
      <link href="2021/02/05/day12/"/>
      <url>2021/02/05/day12/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/river.png" alt="cover"></p><h4 id="一、直播简介"><a href="#一、直播简介" class="headerlink" title="一、直播简介"></a>一、直播简介</h4><p> 直播分为：现场直播和观看直播，现场直播称为推流，观看直播称为拉流，一套流程走下去就可完成直播</p><h4 id="二、搭建HTTP-Flv协议"><a href="#二、搭建HTTP-Flv协议" class="headerlink" title="二、搭建HTTP-Flv协议"></a>二、搭建HTTP-Flv协议</h4><h5 id="在云主键进行部署环境"><a href="#在云主键进行部署环境" class="headerlink" title="在云主键进行部署环境"></a>在云主键进行部署环境</h5><p>创建保存的目录</p><pre><code class="js">mkdir /usr/local/nginx-flv# 创建了一个安装目录mkdir /home/flv-tools# 存储所需软件</code></pre><p>下载所需文件</p><pre><code class="js">wget https://nginx.org/download/nginx-1.18.0.tar.gz</code></pre><p>下载直播模块</p><pre><code class="js">git clone https://github.com/winshining/nginx-http-flv-module</code></pre><p>解压nginx和直播模块</p><pre><code class="js">tar -zxvf nginx-1.18.0.tar.gz nginx-1.18.0/unzip nginx-http-flv-module.zip</code></pre><p>进入nginx目录下进行配置</p><pre><code class="js">cd nginx-1.18.0# --prefix: 配置安装路径#--add-module: 添加安装插件./configure --prefix=/usr/local/nginx-flv --add-module=/home/flv-tools/nginx-http-flv-module-master</code></pre><p>编译及安装</p><pre><code class="js">make make install # 或者使用make &amp;&amp; make install </code></pre><h4 id="三、配置文件修改"><a href="#三、配置文件修改" class="headerlink" title="三、配置文件修改"></a>三、配置文件修改</h4><pre><code class="js">vim /usr/local/nginx-flv/conf/nginx.confworker_processes  1;rtmp_auto_push on;rtmp_auto_push_reconnect 1s;rtmp_socket_dir /tmp;rtmp&#123;    out_queue 4096;    out_cork 8;    max_streams 128;    timeout 15s;    drop_idle_publisher 15s;    log_interval 5s;    log_size 1m;    server &#123;        listen 1935; # 推流端口        server_name zege;        application live &#123;    # 配置推流地址            live on; # 打开推流            # gop_cache on;            # rtmp://123.123.123.123:1935/live/test        &#125;    &#125;&#125;events &#123;    worker_connections  1024;&#125;</code></pre><p>配置文件http拉流部分</p><pre><code class="js">http &#123;    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    server &#123;        listen       8080; # 拉流通过8080去拉流        # http://123.123.123.123:8080/live/?port=1935&amp;stream=test        server_name  localhost;        location /live &#123;            flv_live on;            chunked_transfer_encoding  on;            add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;            add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;        &#125;    &#125;&#125;</code></pre><p>·关闭旧有服务</p><pre><code class="js">/usr/local/nginx-rtmp/sbin/nginx -s stop/usr/local/nginx-rtmp/sbin/nginx -s reload# 重启</code></pre><p>开启新服务</p><pre><code class="js">/usr/local/nginx-flv/sbin/nginx -c /usr/local/nginx-flv/conf/nginx.conf</code></pre><h4 id="四、打开OBS进行推流配置"><a href="#四、打开OBS进行推流配置" class="headerlink" title="四、打开OBS进行推流配置"></a>四、打开OBS进行推流配置</h4><p>推流地址为:rtmp://39.106.221.128:22/live/123</p><h4 id="五、打开VLC进行拉流"><a href="#五、打开VLC进行拉流" class="headerlink" title="五、打开VLC进行拉流"></a>五、打开VLC进行拉流</h4><p>拉流地址为:<a href="http://39.106.221.128:22/live?port=1935&amp;app=live&amp;stream=123">http://39.106.221.128:22/live?port=1935&amp;app=live&amp;stream=123</a></p><h4 id="六、Vue实现拉流"><a href="#六、Vue实现拉流" class="headerlink" title="六、Vue实现拉流"></a>六、Vue实现拉流</h4><p>安装<strong>flv.js</strong>开源工具，进行拉流</p><pre><code class="js">cnpm install flv.js --save</code></pre><p>导包</p><pre><code class="js">import flv from &#39;flv.js&#39;</code></pre><p>构建页面标签，播放标签</p><pre><code class="js">&lt;video id=&quot;videoElement&quot; controls muted&gt;      Your browser is too old which doesn&#39;t support HTML5 video.&lt;/video&gt;</code></pre><p>进行初始化</p><pre><code class="js"> mounted() &#123;    var videoElement = document.getElementById(&#39;videoElement&#39;);    var flvPlayer = flv.createPlayer(&#123;      type: &#39;flv&#39;,      enableWorker: true,     //浏览器端开启flv.js的worker,多进程运行flv.js      isLive: true,           //直播模式      hasAudio: false,        //关闭音频      hasVideo: true,      // cors: true,      stashInitialSize: 128,      enableStashBuffer: false, //播放flv时，设置是否启用播放缓存，只在直播起作用。      // url: &#39;http://192.168.2.234/flv/323223618780001&#39;      // url: &#39;http://39.105.79.238:8080/live?port=1935&amp;app=live&amp;stream=test&#39;      url: &#39;http://47.93.48.154:8080/live?port=1935&amp;app=live&amp;stream=test&#39;    &#125;)    flvPlayer.attachMediaElement(videoElement);    flvPlayer.load();    flvPlayer.play();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 直播 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无限极自关联</title>
      <link href="2021/02/04/day11/"/>
      <url>2021/02/04/day11/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/river.png" alt="cover"></p><h4 id="一、什么是无限极自关联"><a href="#一、什么是无限极自关联" class="headerlink" title="一、什么是无限极自关联"></a>一、什么是无限极自关联</h4><p>无限极分类其实就是一棵树，所有的节点作为一个存储元素。每个节点可以有任意个孩子节点，且只有一个父节点。</p><h4 id="二、后端部署"><a href="#二、后端部署" class="headerlink" title="二、后端部署"></a>二、后端部署</h4><h5 id="models-py"><a href="#models-py" class="headerlink" title="models.py"></a>models.py</h5><pre><code class="js">class Admin(models.Model):    name = models.CharField(max_leng=20)     uid = models.ForeignKey(to=&#39;self&#39;, on_delete=models.SETNULL, default=None) # 自关联</code></pre><h5 id="serializers-py"><a href="#serializers-py" class="headerlink" title="serializers.py"></a>serializers.py</h5><pre><code class="js">class AdminSer(ModelSerializer):    class Meta:        model = Path        fields = &#39;__all__&#39;</code></pre><h5 id="views-py"><a href="#views-py" class="headerlink" title="views.py"></a>views.py</h5><pre><code class="js"># 无限自关联递归函数def function(id):    # 接收id 查询结果集    query = User.objects.filter(uid=id)    # 进行序列化    admin = UserSer(query, many=True).data    # 在序列化结果中添加空列表    admin[&#39;list&#39;] = []    # 遍历结果集，递归调用并将调用结果存入上级列表    for i in admin:        admin[&#39;list&#39;].append(functions(i.uid))    # 返回结果集    return adminclass Admin(APIView):    def get(self, request):        # 定义列表        admin_list = []        # 查取所有信息        admin = Path.objects.all()        # 遍历开始递归查询        for i in admin:            admin_list.append(function(i.id))            retrun Response(admin_list)</code></pre><h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>   部署一个父节点，可以有多个子节点的加入，然后进行遍历数据，关联自己进行查询，最后进行添加</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无极限自关联 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webshell</title>
      <link href="2021/02/03/day10/"/>
      <url>2021/02/03/day10/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/river.png" alt="cover"></p><h4 id="一、什么是webshell"><a href="#一、什么是webshell" class="headerlink" title="一、什么是webshell"></a>一、什么是webshell</h4><p>webshell是指在web服务器上的一个脚本程序，通过这个脚本程序可以上传下载文件、查看数据库信息以及调用一些系统命令等。Webshell 获取网站服务器的权限(shell)。</p><h4 id="二、webshell原理"><a href="#二、webshell原理" class="headerlink" title="二、webshell原理"></a>二、webshell原理</h4><p>本地可以通过远程连接的方式和网站的webshell建立连接，本地发送命令后，网站的shell脚本就会去执行此命令，从而达到管理网站的效果。</p><h4 id="三、webshell的分类有哪些？"><a href="#三、webshell的分类有哪些？" class="headerlink" title="三、webshell的分类有哪些？"></a>三、webshell的分类有哪些？</h4><pre><code>大马，小马，一句话木马等。</code></pre><p>小马：</p><pre><code>体积小、功能少、一般他只有文件上传功能</code></pre><p>大马:</p><pre><code>体积大、功能齐全、能够管理数据库、文件管理、对站点进行快速的信息收集，甚至能够提权。</code></pre><p>一句话木马:</p><pre><code>短小精悍、功能强大、隐蔽性好、使用客户端可以快速管理webshell</code></pre><h4 id="四、webshell的隐蔽性"><a href="#四、webshell的隐蔽性" class="headerlink" title="四、webshell的隐蔽性"></a>四、webshell的隐蔽性</h4><p>有些恶意网页脚本可以嵌套在正常网页中运行，且不容易被查杀。</p><p>webshell可以穿越服务器防火墙，由于与被控制的服务器或远程主机交换的数据都是通过80端口传递的，因此不会被防火墙拦截。并且使用webshell一般不会在系统日志中留下记录，只会在网站的web日志中留下一些数据提交记录，没有经验的管理员是很难看出入侵痕迹的。</p><h4 id="五、后端部分"><a href="#五、后端部分" class="headerlink" title="五、后端部分"></a>五、后端部分</h4><p>进行导包</p><pre><code class="js">from dwebsocket import accept_websocketimport timeimport paramikofrom threading import Thread</code></pre><h5 id="views-py配置"><a href="#views-py配置" class="headerlink" title="views.py配置"></a>views.py配置</h5><p>进行连接函数</p><pre><code class="js">def make_ssh(host=&quot;127.0.0.1&quot;, username=&quot;root&quot;, password=&quot;123456&quot;):    &quot;&quot;&quot;    :host 主机地址    :username 用户名，一般是root    :password 密码    :port ssh协议的端口,22    &quot;&quot;&quot;    # 初始化一个ssh对象    sh = paramiko.SSHClient()    # 设置对象连接密钥规则    sh.set_missing_host_key_policy(paramiko.AutoAddPolicy())    # 连接    sh.connect(host, username=username, password=password, port=22)    # 生成shell对象    channle = sh.invoke_shell(term=&#39;xterm&#39;)    return channle</code></pre><p>接收函数</p><pre><code class="js">def recv_ssh_msg(channle, ws):    &#39;&#39;&#39;        只管接收    &#39;&#39;&#39;    # 判断shell连接对象是否没有退出    while not channle.exit_status_ready():        # 接收过程可能会因为没有任何返回而报错        try:            buf = channle.recv(1024)  # 接收命令的执行结果            ws.send(buf)  # 向Websocket通道返回        # 接收不到会报错，但是报错没关系，继续重新尝试接受        except:            break</code></pre><p>连接视图函数</p><pre><code class="js">@accept_websocketdef webssh(request):    if request.is_websocket:        # 1. 获取到连接对象        ws = request.websocket        # 2. 初始化linux连接        channel = make_ssh()        # 3. 初始化linux数据接收线程，并开启        recv_thread = Thread(target=recv_ssh_msg, args=(channel, ws))        recv_thread.start()        while 1:  # 主线程: 只管发送            # 2. 阻塞ws接收发来的数据            cmd = ws.wait()            # cmd = ws.recv()            if cmd:                channel.send(cmd)  # 发送到linux 去执行            else:  # 如果连接断开，那么cmd将会发一个空包                break        recv_thread.join()  # 回收子线程        ws.close()  # 关闭ws连接</code></pre><h3 id="六、前端部分"><a href="#六、前端部分" class="headerlink" title="六、前端部分"></a>六、前端部分</h3><p>在vue中导入插件</p><pre><code class="js">import * as attach from &#39;xterm/lib/addons/attach/attach&#39; // 安装插件适，可以使用attach去添加import * as fit from &#39;xterm/lib/addons/fit/fit&#39; // fit进行自适应大小的import &#123; Terminal &#125; from &#39;xterm&#39;Terminal.applyAddon(attach) // 添加插件Terminal.applyAddon(fit) // 添加插件</code></pre><p>初始化黑窗口对象</p><pre><code class="js">&lt;template&gt;&lt;div id=&quot;terminal&quot;&gt;    &lt;!--黑色窗口--&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;    &#125;  &#125;,mounted() &#123;        // 获取到了div标签        let terminalContainer = document.getElementById(&#39;terminal&#39;)        // 初始化黑窗口对象        this.term = new Terminal(this.terminal)        // 打开这个对象        this.term.open(terminalContainer)        new WebSocket(&#39;ws://127.0.0.1:8000/webssh/&#39;)        this.terminalSocket = new WebSocket(&#39;ws://127.0.0.1:8000/webssh/&#39;)        this.terminalSocket.onopen = function()&#123; // 连接成功触发该方法            console.log(&#39;websocket is Connected...&#39;)        &#125;        this.terminalSocket.onclose = function()&#123; // 连接关闭适触发的方法            console.log(&#39;websocket is Closed...&#39;)        &#125;        this.terminalSocket.onerror = function()&#123; // 连接出错触发的方法            console.log(&#39;damn Websocket is broken!&#39;)        &#125;        this.term.attach(this.terminalSocket)    &#125;&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis订阅与发布</title>
      <link href="2021/02/01/day08/"/>
      <url>2021/02/01/day08/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/river.png" alt="cover"></p><h4 id="一、什么是Redis"><a href="#一、什么是Redis" class="headerlink" title="一、什么是Redis"></a>一、什么是Redis</h4><p>Redis是一个开源的内存数据库，它以键值对的形式存储数据。由于数据存储在内存中，因此Redis的速度很快，但是每次重启Redis服务时，其中的数据也会丢失，因此，Redis也提供了持久化存储机制(AOF,RDB)，将数据以某种形式保存在文件中，每次重启时，可以自动从文件加载数据到内存当中。 </p><h4 id="二、什么是发布订阅"><a href="#二、什么是发布订阅" class="headerlink" title="二、什么是发布订阅"></a>二、什么是发布订阅</h4><p>Redis 发布订阅是一种消息通信模式：发送者发送消息，订阅者接收消息。</p><h4 id="三、发布者"><a href="#三、发布者" class="headerlink" title="三、发布者"></a>三、发布者</h4><p>发布者是用来发布消息</p><p>publish 将信息发送到指定的频道</p><p>语法:</p><pre><code>publish channel message</code></pre><p> 返回结果:</p><pre><code>接收到信息的订阅者数量</code></pre><pre><code class="js">import timeimport redisnumber = [&#39;2000&#39;, &#39;2001&#39;, &#39;2002&#39;, &#39;2003&#39;]sing = [&#39;12&#39;, &#39;30&#39;, &#39;1&#39;, &#39;30&#39;]redis = redis.Redis(host=&#39;127.0.0.1&#39;, port=&#39;6379&#39;, db=0, password=&#39;密码即可&#39;)for i in range(len(number)):    value = str(number[i]) + &#39; &#39; + str(sing[i])    redis.publish(&quot;ceshi&quot;, value)  #发布消息到ceshi</code></pre><h4 id="三、订阅者"><a href="#三、订阅者" class="headerlink" title="三、订阅者"></a>三、订阅者</h4><pre><code class="js">import timeimport redisredis = redis.Redis(host=&#39;127.0.0.1&#39;, port=&#39;6379&#39;, db=1, password=&#39;密码即可&#39;)ps = redis.pubsub()ps.subscribe(&#39;liao&#39;)  #从liao订阅消息for item in ps.listen():        #监听状态：有消息发布了就拿过来    if i[&#39;type&#39;] == &#39;message&#39;:        print i[&#39;change&#39;]        print i[&#39;data&#39;]</code></pre><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p>①连接方式使用python连接redis<br>②是订阅方法。这里使用的是Redis类中的pubsub方法。连接好之后，可使用subscribe方法来订阅redis消息。其中subscribe是订阅一个频道，之后就可以开始监听了。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis订阅与发布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis键空间事件</title>
      <link href="2021/02/01/day09/"/>
      <url>2021/02/01/day09/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/river.png" alt="cover"></p><h2 id="Redis键空间介绍"><a href="#Redis键空间介绍" class="headerlink" title="Redis键空间介绍"></a>Redis键空间介绍</h2><p>使用场景:</p><p>在购物项目中，如果完成提交订单而没有支付成功的状态时，redis会在规定的时间内删除订单，redis保存订单后，设置过期时间，时间过后数据删除</p><p>促销活动结束之后，促销活动开始之前设置redis,到期删除，通过回调函数拿到key, 执行回调库存脚本</p><h4 id="一、开启键空间通知"><a href="#一、开启键空间通知" class="headerlink" title="一、开启键空间通知"></a>一、开启键空间通知</h4><p>在cmd窗口，默认键空间通知是关闭的,需要在终端开启</p><pre><code>redis-cli config set notify-keyspace-events KEAok</code></pre><p>key值可能让事件被启用</p><table><thead><tr><th align="center">字符</th><th align="left">发送的通知</th></tr></thead><tbody><tr><td align="center">K</td><td align="left">键空间通知，所有通知以__keyspace@<db>__为前缀</td></tr><tr><td align="center">E</td><td align="left">键空间通知，所有通知以__keyevent@<db>__为前缀</td></tr><tr><td align="center">g</td><td align="left">DEL、EXPIRE、RENAME等类型无关的通用命令通知</td></tr><tr><td align="center">$</td><td align="left">字符串命令通知</td></tr><tr><td align="center">l</td><td align="left">列表命令通知</td></tr><tr><td align="center">s</td><td align="left">结合命令通知</td></tr><tr><td align="center">h</td><td align="left">哈希命令通知</td></tr><tr><td align="center">z</td><td align="left">有序集合命令通知</td></tr><tr><td align="center">x</td><td align="left">过期事件:每当有过期键被删除时发送</td></tr><tr><td align="center">e</td><td align="left">驱逐(evict)事件:每当有键因为maxmemory政策而被删除时发送</td></tr><tr><td align="center">A</td><td align="left">参数g$lshzxe的别名</td></tr></tbody></table><h4 id="二、检查事件是否正常"><a href="#二、检查事件是否正常" class="headerlink" title="二、检查事件是否正常"></a>二、检查事件是否正常</h4><pre><code>1 redis-cli --csv psubscribe &#39;*&#39;  2 # 结果   3 Reading messages... (press Ctrl-C to quit)  4 &quot;psubscribe&quot;,&quot;*&quot;,1</code></pre><h4 id="三、配置回调函数"><a href="#三、配置回调函数" class="headerlink" title="三、配置回调函数"></a>三、配置回调函数</h4><p>在python的视图类中进行配置</p><pre><code class="js"># 连接redis数据库redis = Redis(host=&#39;127.0.0.1&#39;, port=6379, decode_responses=True)# 监听新消息pubsub = redis.pubsub()# 定义触发事件def orderbuy(msg):    order_id = str(msg[&#39;data&#39;])    # 获取订单对象    order = Order.objects.get(order_id=order_id)    # 判断用户是否已经付款    if str(order.status) == &quot;1&quot;:        # 取消订单,更改订单状态        Order.objects.filter(order_id=order_id).update(status=&quot;2&quot;)        # 获取订单中的所有商品        goods = order.objects.all()        # 遍历商品        for good in goods:            # 获取订单中的商品数量            count = good.count            print(count)            # 获取name商品            name = good.name            # 将库存重新增加到sku的stock中去            name.stock += count            # 从销量中减去已经取消的数量            name.sales -= count            name.save()#订阅redis键空间通知pubsub.psubscribe(**&#123;&#39;__keyevent@0__:expired&#39;: event_handler&#125;)# 死循环,接收订阅的通知while True:    message = pubsub.get_message()    if message:        print(message)    else:        time.sleep(0.1)</code></pre><pre><code>keyevent@0:expired’:设定通知类型: keyspace、keyevent设置事件类型: expired选中数据库号: @0()</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在购物车项目中进行添加，先在终端开启redis的键空间，然后开启键空间，在新的终端打开redis进行创建数据，就会有数据发送给键空间，然后保存，最后在python的视图函数中进行配置redis监听数据，判断是否支持，再发送数据给键空间，进行无线循环获取订阅获取的通知。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis键空间事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>celery异步框架</title>
      <link href="2021/01/30/day06/"/>
      <url>2021/01/30/day06/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/river.png" alt="cover"></p><h2 id="关于Celery"><a href="#关于Celery" class="headerlink" title="关于Celery"></a>关于Celery</h2><pre><code>Celery 是一款非常简单、灵活、可靠的分布式系统，可用于处理大量消息，并且提供了一整套操作此系统的一系列工具，同时Celery 是一款消息队列工具，可用于处理实时数据以及任务调度。</code></pre><h4 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h4><pre><code>pip install celery</code></pre><h4 id="二、注册创建任务"><a href="#二、注册创建任务" class="headerlink" title="二、注册创建任务"></a>二、注册创建任务</h4><pre><code class="js">from celery import Celeryimport timeredis=Celery(&#39;hello&#39;, broker=&#39;redis://127.0.0.1:6379&#39;, backend=&#39;redis://127.0.0.1:6379&#39;)@redis.taskdef sendto():    print(&quot;hello gaolei&quot;)    time.sleep(5)    return &quot;发送成功&quot;if __name__ == &#39;__main__&#39;:    res=sendto.delay()    print(res)</code></pre><p>task共享</p><p>用shared_task修饰时，不需要依赖于指定实例对象。</p><pre><code class="js">from celery import shared_task@shared_taskdef foo():    return &quot;hello world&quot;if __name__ == &#39;__main__&#39;:    res=foo.delay()    print(res)</code></pre><h4 id="三、启动Worker"><a href="#三、启动Worker" class="headerlink" title="三、启动Worker"></a>三、启动Worker</h4><p>启动Worker，监听Broker中是否有任务，</p><pre><code>celery -A tasks worker --loglevel=info</code></pre><h4 id="四、调用任务"><a href="#四、调用任务" class="headerlink" title="四、调用任务"></a>四、调用任务</h4><p>在主程序中调用任务，掉任务发送给 Broker， 而不是真正执行该任务</p><pre><code class="js">from tasks import sendtoimport timedef register():    start = time.time()    print(&quot;插入记录到数据库&quot;)    print(&quot;2. celery发送hello gaolei&quot;)    sendto.delay(&quot;hello&quot;)    print(&quot;注册成功&quot;)    print(&quot;耗时：%s 秒 &quot; % (time.time() - start))if __name__ == &#39;__main__&#39;:    register()</code></pre><p>执行任务花费5秒</p><h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><pre><code>celery的设计于很多模块相耦合，比如broker可以使用redis来进行操作相对于保存结果而言，celery需要在某个地方存储或发送状态，支持内置后端。程序运行过程中，要执行耗时的任务，不想主程序被阻塞，常见的方法是多线程。但是多线程并发过量也需要限制并发个数所以使用celery。</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> celery异步框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三方支付</title>
      <link href="2021/01/29/day05/"/>
      <url>2021/01/29/day05/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/river.png" alt="cover"></p><h2 id="三方支付"><a href="#三方支付" class="headerlink" title="三方支付"></a>三方支付</h2><p>1、注册一个沙箱号：<a href="https://open.alipay.com/platform/home.htm">https://open.alipay.com/platform/home.htm</a></p><h4 id="一、安装插件"><a href="#一、安装插件" class="headerlink" title="一、安装插件"></a>一、安装插件</h4><pre><code class="js">pip install python-alipay-sdk --upgrade</code></pre><h4 id="二、在settings中配置"><a href="#二、在settings中配置" class="headerlink" title="二、在settings中配置"></a>二、在settings中配置</h4><pre><code class="js">ALIPAY_APPID = &#39;&#39;ALIPAY_URL = &quot;&quot;ALIPAY_DEBUG = TrueAPP_PRIVATE_KEY_PATH = &#39;&#39;ALIPAY_PUBLIC_KEY_PATH = &#39;&#39;ALIPAY_GATE = &#39;https://openapi.alipaydev.com/gateway.do?&#39;</code></pre><h4 id="三、发起支付"><a href="#三、发起支付" class="headerlink" title="三、发起支付"></a>三、发起支付</h4><p>请求方式：Get</p><pre><code class="js">from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom orders.models import *from rest_framework import statusfrom alipay import AliPay  #支付from mall import settingsclass AliPayURLView(APIView):    def get(self, request, order_id):        # 根据order_id查询订单对象        try:            order_obj = OrderInfo.objects.get(pk=order_id)        except:            raise Exception(&quot;订单号无效&quot;)        # 创建alipay对象        alipay = AliPay(            appid=settings.ALIPAY_APPID,            app_notify_url=None,            app_private_key_path=settings.ALIPAY_PRIVATE_KEY_PATH,            alipay_public_key_path=settings.ALIPAY_PUBLIC_KEY_PATH,            debug=settings.ALIPAY_DEBUG        )    subject=&#39;支付宝支付&#39;        # 跳转到 https://openapi.alipay.com/gateway.do? + order_string    order_string = alipay.api_alipay_trade_page_pay(        out_trade_no=order_id,        total_amount=str(order.total_amount), # 这里类型我们要由 decimal转换为 str        subject=subject,        return_url=&quot;http://127.0.0.1/pay_success.html&quot;    )    #  拼接url,并且返回    url = settings.ALIPAY_URL + &#39;?&#39; + order_string    return Response(&#123;&#39;alipay_url&#39;:url&#125;)</code></pre><h4 id="五、保存支付结果"><a href="#五、保存支付结果" class="headerlink" title="五、保存支付结果"></a>五、保存支付结果</h4><p>请求方式： PUT<br>路径：/pay/?参数</p><pre><code class="js"> class PayStatusAPIView(APIView):    def put(self,request):    # 1. 创建alipay对象    app_private_key_string = settings.APP_PRIVATE_KEY_PATH    alipay_public_key_string = settings.ALIPAY_PUBLIC_KEY_PATH    alipay = AliPay(        appid=settings.ALIPAY_APPID,        app_notify_url=None,  # 回调url        app_private_key_string=app_private_key_string,        # 支付宝的公钥，验证支付宝回传消息使用        alipay_public_key_string=alipay_public_key_string,        sign_type=&quot;RSA2&quot;,          debug=settings.ALIPAY_DEBUG  # 默认False    )    # 2.验证数据    data = request.query_params.dict()    # sign 不能参与签名验证    signature = data.pop(&quot;sign&quot;)    # verify确认是否成功    success = alipay.verify(data, signature)    if success:        # 3.验证成功之后,可以从 data中获取 支付宝的订单id和 我们的订单id        # 支付宝的交易id        trade_id = data.get(&#39;trade_id&#39;)        # 商家id        out_trade_id = data.get(&#39;out_trade_id&#39;)        #1. 把支付宝的订单id和 我们的订单id 保存起来        Payment.objects.create(           order_id=out_trade_id,            trade_id=trade_id        )        # 2. 更新订单的状态        OrderInfo.objects.filter(order_id=out_trade_no).update(status=OrderInfo.ORDER_STATUS_ENUM[&#39;UNSEND&#39;])        #3. 返回 支付宝的订单id        return Response(&#123;&#39;trade_id&#39;:trade_id&#125;)</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>先创建沙箱账号，支付宝登录获取ALIPAY_APPID等信息，保存在settings.py文件下然后进行视图的编写，判断是否有下单时的订单号然后进行获取回调地址等信息，最后回调返回支付成功保存数据完成支付接口</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三方支付 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios拦截器</title>
      <link href="2021/01/28/day07/"/>
      <url>2021/01/28/day07/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/river.png" alt="cover"></p><h2 id="Axios拦截器使用教程"><a href="#Axios拦截器使用教程" class="headerlink" title="Axios拦截器使用教程"></a>Axios拦截器使用教程</h2><h4 id="一、安装axios"><a href="#一、安装axios" class="headerlink" title="一、安装axios"></a>一、安装axios</h4><pre><code>npm install axios --save</code></pre><h4 id="二、配置axios实例"><a href="#二、配置axios实例" class="headerlink" title="二、配置axios实例"></a>二、配置axios实例</h4><p>在src文件下创建文件夹http，然后再里面创建index.js和api.js</p><p>index.js是用来分装axios和请求方法的，api.js是用来调用方法。</p><h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><pre><code class="js">// 配置axios基本的属性const axios = require(&#39;axios&#39;)axios.defaults.baseURL = &#39;http://127.0.0.1:8000&#39; // 请求的接口主域名axios.defaults.timeout = 5000 // 请求超时的设置 5s// 请求拦截axios.interceptors.request.use(    //config 代表是你请求的一些信息    config =&gt; &#123;        // 在请求发送之前的操作        // 可以进行token的保持等......        return config    &#125;,    error =&gt; &#123;        // 对错误请求的处理        // 弹出错误请求消息        console.log(error)        return Promise.reject(error)    &#125;)//  response拦截器 响应拦截器 请求之后的操作axios.interceptors.response.use(    config =&gt; &#123;        return config    &#125;,    error =&gt; &#123;        return Promise.reject(error)    &#125;)/** * post方法，对应post请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] * @param &#123;Object&#125; headers [请求时的头部] **/// get方法export function get(url, params, headers) &#123;  return new Promise((resolve, reject) =&gt; &#123;    axios.get(url, &#123;params, headers&#125;).then(res =&gt; &#123;      resolve(res)    &#125;).catch(err =&gt; &#123;      reject(err)    &#125;)  &#125;)&#125;//post方法export function post(url, params, headers) &#123;  return new Promise((resolve, reject) =&gt; &#123;    axios.post(url, params, headers).then((res) =&gt; &#123;      resolve(res)    &#125;).catch((err) =&gt; &#123;      // debugger      reject(err)    &#125;)  &#125;)&#125;//put方法export function put(url, params, headers) &#123;  return new Promise((resolve, reject) =&gt; &#123;    axios.put(url, params, headers).then((res) =&gt; &#123;      resolve(res)    &#125;).catch((err) =&gt; &#123;      // debugger      reject(err)    &#125;)  &#125;)&#125;//delete方法export function del(url, params, headers) &#123;  return new Promise((resolve, reject) =&gt; &#123;    axios.delete(url, &#123;data: params, headers&#125;).then((res) =&gt; &#123;      resolve(res)    &#125;).catch((err) =&gt; &#123;      // debugger      reject(err)    &#125;)  &#125;)&#125;export default axios;</code></pre><h3 id="四、在api下进行使用所分装的方法"><a href="#四、在api下进行使用所分装的方法" class="headerlink" title="四、在api下进行使用所分装的方法"></a>四、在api下进行使用所分装的方法</h3><h4 id="api-js"><a href="#api-js" class="headerlink" title="api.js"></a>api.js</h4><pre><code class="js">import &#123;get, post, put, del&#125; from &#39;./index&#39;//get方法export const 调用名 = parameter =&gt; &#123;  return get(    &#39;路由地址&#39;,    parameter,  )&#125;// post方法export const 调用名 = parameter =&gt; &#123;  return post(    &#39;路由地址&#39;,    parameter,  )&#125;// put方法export const 调用名 = parameter =&gt; &#123;  return put(    &#39;路由地址&#39;,    parameter,  )&#125;// delete方法export const 调用名 = parameter =&gt; &#123;  return del(    &#39;路由地址&#39;,    parameter,  )&#125;</code></pre><h3 id="五、最后在vue组件中进行使用"><a href="#五、最后在vue组件中进行使用" class="headerlink" title="五、最后在vue组件中进行使用"></a>五、最后在vue组件中进行使用</h3><h4 id="project-vue"><a href="#project-vue" class="headerlink" title="project.vue"></a>project.vue</h4><pre><code class="js">import &#123;调用名&#125; from &quot;@/http/api.js&quot;;export default &#123;  created() &#123;    调用名()      .then(res =&gt; &#123;        console.log(res);      &#125;)      .catch(err =&gt; &#123;        console.log(err);      &#125;);  &#125;&#125;</code></pre><h4 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h4><pre><code>在使用axios拦截器需要注意，先保证有axios的包，设置axios的请求接口然后进行分装请求拦截器，请求拦截器是在发送请求时所调用的方法，响应拦截器是在请求后进行的操作。然后分装get等方法进行使用，最后在vue组件中进行调用方法然后进行请求接口的访问。</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios拦截器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微博三方登录</title>
      <link href="2021/01/28/day4/"/>
      <url>2021/01/28/day4/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/river.png" alt="cover"></p><h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><p>首先需要注册”新浪微博开放平台”：<a href="https://open.weibo.com/">https://open.weibo.com</a></p><p>添加网站应用前需要先提交认证审核，然后添加完网站应用再提交应用审核。</p><p>创建完应用后会有一个 App Key 和 App Secret。</p><h5 id="1-获取-code"><a href="#1-获取-code" class="headerlink" title="1.获取 code"></a>1.获取 code</h5><p>第三方客户端引导用户发送get请求</p><pre><code>https://api.weibo.com/oauth2/authorize</code></pre><p>参数：</p><table><thead><tr><th align="center">参数名</th><th align="center">是否必须</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">client_id</td><td align="center">是</td><td align="left">申请应用时分配的AppKey。</td></tr><tr><td align="center">redirect_uri</td><td align="center">是</td><td align="left">授权回调地址。</td></tr><tr><td align="center">scope</td><td align="center">否</td><td align="left">申请scope权限所需参数，可一次申请多个scope权限，用逗号分隔</td></tr><tr><td align="center">state</td><td align="center">否</td><td align="left">用于保持请求和回调的状态，在回调时，会在Query Parameter中回传该参数</td></tr><tr><td align="center">display</td><td align="center">否</td><td align="left">授权页面的终端类型，取值见下面的说明。</td></tr><tr><td align="center">forcelogin</td><td align="center">否</td><td align="left">是否强制用户重新登录，true：是，false：否。默认false。</td></tr><tr><td align="center">language</td><td align="center">否</td><td align="left">授权页语言，缺省为中文简体版，en为英文版。</td></tr></tbody></table><p>这时会跳转到登入授权页面，授权后新浪微博会向客户端返回到我们的创建应用的时候填写的那个回调地址。并且带着code参数</p><h5 id="2-通过-code-获取-access-token"><a href="#2-通过-code-获取-access-token" class="headerlink" title="2.通过 code 获取 access_token"></a>2.通过 code 获取 access_token</h5><p>有了code，我们在通过 <code>App Key</code> 、<code>App Secret</code> 和<code>code</code>等参数去发送 post 请求，获取 <code>access_token</code></p><pre><code>https://graph.qq.com/oauth2.0/token</code></pre><h6 id="注意，虽然是post请求，但是参数是通过get传递的-参数："><a href="#注意，虽然是post请求，但是参数是通过get传递的-参数：" class="headerlink" title="注意，虽然是post请求，但是参数是通过get传递的 参数："></a>注意，虽然是post请求，但是参数是通过get传递的 参数：</h6><table><thead><tr><th align="center">参数名</th><th align="center">是否必须</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">client_id</td><td align="center">是</td><td align="left">申请应用时分配的AppKey。</td></tr><tr><td align="center">client_secret</td><td align="center">是</td><td align="left">申请应用时分配的AppSecret。</td></tr><tr><td align="center">grant_type</td><td align="center">是</td><td align="left">请求的类型，填写authorization_code</td></tr><tr><td align="center">code</td><td align="center">是</td><td align="left">调用authorize获得的code值。</td></tr><tr><td align="center">redirect_uri</td><td align="center">是</td><td align="left">回调地址，需需与注册应用里的回调地址一致。</td></tr></tbody></table><h6 id="返回数据包括-access-token-、uid等信息："><a href="#返回数据包括-access-token-、uid等信息：" class="headerlink" title="返回数据包括 access_token 、uid等信息："></a>返回数据包括 access_token 、uid等信息：</h6><pre><code class="js"> &#123;       &quot;access_token&quot;: &quot;&quot;,       &quot;expires_in&quot;: &#39;&#39;,       &quot;remind_in&quot;:&quot;&quot;,       &quot;uid&quot;:&quot;&quot; &#125;</code></pre><h5 id="3-用-access-token-获取用户信息"><a href="#3-用-access-token-获取用户信息" class="headerlink" title="3.用 access_token 获取用户信息"></a>3.用 access_token 获取用户信息</h5><p>get请求地址：</p><pre><code>https://api.weibo.com/2/users/show.json</code></pre><p>参数：</p><table><thead><tr><th align="center">参数名</th><th align="center">是否必须</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">access_token</td><td align="center">是</td><td align="left">采用OAuth授权方式为必填参数，OAuth授权后获得。</td></tr><tr><td align="center">uid</td><td align="center">否</td><td align="left">需要查询的用户ID。</td></tr><tr><td align="center">screen_name</td><td align="center">否</td><td align="left">需要查询的用户昵称。</td></tr></tbody></table><p>注意：参数uid与screen_name二者必选其一，且只能选其一。</p><p>我们可以用返回的 access_token 与 uid 访问获取用户信息</p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><h4 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h4><p>首先在settings中配置</p><pre><code class="js"># 微博第三方登录配置App_Key = &#39;&#39;  # App KeyApp_Secret = &#39;&#39;  # App SecretMicroBlog_URL = &#39;&#39;  # 回调页地址</code></pre><p>在views.py中进行登录配置操作</p><pre><code class="js">import requestsfrom BlogDjango.settings import App_Key, App_Secret, MicroBlog_URLfrom rest_framework.views import APIViewfrom rest_framework.response import Responsefrom django.shortcuts import redirectclass MicroBlogView(APIView):    # 使用微博开放平台可以使用get和post    def get(self, request):        micro_url = &#39;https://api.weibo.com/oauth2/authorize?client_id=&#123;&#125;&amp;redirect_uri=&#123;&#125;&#39;.format(App_Key, MicroBlog_URL)        return Response(&#123;&#39;url&#39;: micro_url&#125;)    # 使用新浪开放平台OAuth2/access_token接口, 只能使用post方法    def post(self, request):        # 获取code, 去访问token        code = request.data.get(&#39;code&#39;, None)        # 使用requests网络请求请求        r = requests.post(&#39;https://api.weibo.com/oauth2/access_token&#39;, &#123;            &#39;client_id&#39;: App_Key,            &#39;client_secret&#39;: App_Secret,            &#39;grant_type&#39;: &#39;authorization_code&#39;,            &#39;code&#39;: code,            &#39;redirect_uri&#39;: MicroBlog_URL        &#125;)        # 获取返回的对象        print(r.json())        access_token = r.json()[&#39;access_token&#39;]        uid = r.json()[&#39;uid&#39;]        if access_token:            return Response(&#123;&#39;msg&#39;: &#39;登录成功&#39;, &#39;code&#39;: 200, &#39;uid&#39;: uid&#125;)        return Response(&#123;&#39;msg&#39;: &#39;登录成功&#39;, &#39;code&#39;: 200&#125;)# 使用微博登录时用到的回调地址def micro_callback(request):    code = request.GET.get(&#39;code&#39;, None)    return redirect(&#39;http://127.0.0.1:8080/#/oauthCallback?code=&#39; + code)</code></pre><h4 id="前段部分"><a href="#前段部分" class="headerlink" title="前段部分"></a>前段部分</h4><pre><code class="js">&lt;template&gt;  &lt;div&gt;        &lt;!-- 通过这个weiBoUrl地址可以进入微博的回调页，获取到code并传到后端 --&gt;      &lt;a :href=&quot;weiBoUrl&quot;&gt;微博&lt;/a&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    data() &#123;        return &#123;            weiBoUrl: &#39;&#39;,        &#125;    &#125;,    mounted() &#123;        // 获取微博授权页地址      this.$axios.get(&#39;micro&#39;).then(res=&gt;&#123;        this.weiBoUrl = res.data.url;        console.log(res.data)      &#125;).catch(err=&gt;&#123;        console.log(err)      &#125;)&#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微博三方登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子父组件</title>
      <link href="2021/01/27/day03/"/>
      <url>2021/01/27/day03/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/river.png" alt="cover"></p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h4 id="什么是组件？"><a href="#什么是组件？" class="headerlink" title="什么是组件？"></a>什么是组件？</h4><p>   组件是Vue中的一个重要概念，是一个可以重复使用的Vue是可以复用的Vue实例，它拥有独一无二的组件名称，它可以扩展HTML元素，以组件名称的方式作为自定义的HTML标签。因为组件是可复用的Vue实例，所以它们与new Vue（）接收相同的选项，例如data，computed、watch、methods以及生命周期钩子等。仅有的例外是像el这样根实例特有的选项。</p><h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><h4 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h4><p> ·父组件在组件上定义了一个自定义事件childFn，事件名为parentFn用于接受子组件传过来的message值。</p><pre><code class="js">&lt;!-- 父组件 --&gt;&lt;template&gt;   &lt;div class=&quot;test&quot;&gt;     &lt;test-com @childFn=&quot;parentFn&quot;&gt;&lt;/test-com&gt;     &lt;br/&gt;      子组件传来的值 : &#123;&#123;message&#125;&#125;   &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;   // ...   data() &#123;       return &#123;            message: &#39;&#39;       &#125;   &#125;,   methods: &#123;      parentFn(payload) &#123;       this.message = payload;     &#125;   &#125;&#125;&lt;/script&gt;</code></pre><h4 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h4><p>·子组件是一个buttton按钮，并为其添加了一个click事件，当点击的时候使用$emit()触发事件，把message传给父组件。</p><pre><code class="js">&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;div class=&quot;testCom&quot;&gt;    &lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt;    &lt;button @click=&quot;click&quot;&gt;Send&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    // ...    data() &#123;        return &#123;          // 默认          message: &#39;我是来自子组件的消息&#39;        &#125;    &#125;,    methods: &#123;      click() &#123;            this.$emit(&#39;childFn&#39;, this.message);        &#125;    &#125;    &#125;&lt;/script&gt;</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>·通过”props down , events up”我们就简单的实现了父子组件之间的双向传值</p><h2 id="子父组件通信"><a href="#子父组件通信" class="headerlink" title="子父组件通信"></a>子父组件通信</h2><p>第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法</p><h4 id="父组件-1"><a href="#父组件-1" class="headerlink" title="父组件"></a>父组件</h4><pre><code class="js">&lt;template&gt;  &lt;div&gt;    &lt;check&gt;&lt;/check&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import check from &#39;@/components/check&#39;;  export default &#123;    components: &#123;      check    &#125;,    methods: &#123;      father() &#123;        console.log(&#39;传值成功&#39;);      &#125;    &#125;  &#125;;&lt;/script&gt;</code></pre><h4 id="子组件-1"><a href="#子组件-1" class="headerlink" title="子组件"></a>子组件</h4><pre><code class="js">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;check()&quot;&gt;点击&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    methods: &#123;      check() &#123;        this.$parent.father();      &#125;    &#125;  &#125;;&lt;/script&gt;</code></pre><p>·第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。</p><h4 id="父组件-2"><a href="#父组件-2" class="headerlink" title="父组件"></a>父组件</h4><pre><code class="js">&lt;template&gt;  &lt;div&gt;    &lt;check @fatherMethod=&quot;father&quot;&gt;&lt;/check&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import check from &#39;@/components/check&#39;;  export default &#123;    components: &#123;      check    &#125;,    methods: &#123;      father() &#123;        console.log(&#39;传值成功&#39;);      &#125;    &#125;  &#125;;&lt;/script&gt;</code></pre><h4 id="子组件-2"><a href="#子组件-2" class="headerlink" title="子组件"></a>子组件</h4><pre><code class="js">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;check()&quot;&gt;点击&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    methods: &#123;      check() &#123;        this.$emit(&#39;father&#39;);      &#125;    &#125;  &#125;;&lt;/script&gt;</code></pre><p>·第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法</p><h4 id="父组件-3"><a href="#父组件-3" class="headerlink" title="父组件"></a>父组件</h4><pre><code class="js">&lt;template&gt;  &lt;div&gt;    &lt;check :father=&quot;father&quot;&gt;&lt;/check&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import check from &#39;@/components/check&#39;;  export default &#123;    components: &#123;      check    &#125;,    methods: &#123;      father() &#123;        console.log(&#39;传值成功&#39;);      &#125;    &#125;  &#125;;&lt;/script&gt;</code></pre><h4 id="子组件-3"><a href="#子组件-3" class="headerlink" title="子组件"></a>子组件</h4><pre><code class="js">&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;check()&quot;&gt;点击&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    props: &#123;      father: &#123;        type: Function,        default: null      &#125;    &#125;,    methods: &#123;      check() &#123;        if (this.father) &#123;          this.father();        &#125;      &#125;    &#125;  &#125;;&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue父子组件 子父组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue路由钩子</title>
      <link href="2021/01/26/day02/"/>
      <url>2021/01/26/day02/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/river.png" alt="cover"></p><h2 id="路由钩子函数"><a href="#路由钩子函数" class="headerlink" title="路由钩子函数"></a>路由钩子函数</h2><h4 id="一、路由钩子函数"><a href="#一、路由钩子函数" class="headerlink" title="一、路由钩子函数"></a>一、路由钩子函数</h4><p>路由钩子作用就是拦截导航栏，就是在跳转的时候进行判断</p><pre><code>vue-router 提供的导航钩子主要用来拦截导航，让它完成跳转或取消</code></pre><h5 id="路由钩子分为三类：-全局的、单个路由独享的、或者组件级"><a href="#路由钩子分为三类：-全局的、单个路由独享的、或者组件级" class="headerlink" title="路由钩子分为三类： 全局的、单个路由独享的、或者组件级"></a>路由钩子分为三类： 全局的、单个路由独享的、或者组件级</h5><h4 id="二、全局钩子"><a href="#二、全局钩子" class="headerlink" title="二、全局钩子"></a>二、全局钩子</h4><p>主要包括beforeEach和aftrEach,这类钩子主要作用于全局,一般用来判断权限,以及以及页面丢失时候需要执行的操作。</p><pre><code class="js">1 beforeEach函数有三个参数：2 - to:router即将进入的路由对象3 - from:当前导航即将离开的路由4 - next:Function,进行管道中的一个钩子，如果执行完了，则导航的状态就是 confirmed （确认的）；否则为false，终止导航。5 可以使用router.beforeEach注册一个全局的 before 钩子6 router.beforeEach((to, from, next) =&gt; &#123; // ... &#125;)78 after 钩子没有 next 方法，不能改变导航9 router.afterEach(route =&gt; &#123; // ...&#125;)</code></pre><h4 id="三、单个路由钩子"><a href="#三、单个路由钩子" class="headerlink" title="三、单个路由钩子"></a>三、单个路由钩子</h4><p>主要用于写某个指定路由跳转时需要执行的逻辑</p><pre><code class="js">1 &#123;2        path: &#39;&#39;,3        component: &#39;&#39;,4        meta: &#39;&#39;,5        beforeEnter: (to, from, next) =&gt; &#123;     6            //进入时执行代码块7        &#125;,8        beforeLeave: (to, from, next) =&gt; &#123;9            //离开时执行代码块10        &#125;11    &#125;</code></pre><h4 id="四、组件内的钩子"><a href="#四、组件内的钩子" class="headerlink" title="四、组件内的钩子"></a>四、组件内的钩子</h4><p>主要包括 beforeRouteEnter和beforeRouteUpdate ,beforeRouteLeave,这几个钩子都是写在组件里面也可以传三个参数(to,from,next)。</p><pre><code class="js">1 &lt;script&gt;2  Vue.component(&#39;LifeCircle&#39;,&#123;3    template: &#39;#life-circle&#39;,4    data () &#123;5      return &#123;6      &#125;7    &#125;,8    // 初始化阶段钩子函数9    beforeCreate () &#123; //表示组件创建前的准备工作（ 初始化事件和生命周期 ）     10      //组件未创建，数据拿不到11      console.log(&#39;1&#39;);12    &#125;,13    created () &#123; // 组件创建结束14      console.log(&#39;2&#39;)15    &#125;,16    beforeMount () &#123; 17      console.log( &#39;3&#39; )18    &#125;,19    mounted () &#123;     //表示组件装载结束20      console.log(&#39;4&#39;)21    &#125;22 &lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue路由钩子函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue拦截器</title>
      <link href="2021/01/25/day1/"/>
      <url>2021/01/25/day1/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/river.png" alt="cover"></p><h1 id="Vue拦截器"><a href="#Vue拦截器" class="headerlink" title="Vue拦截器"></a>Vue拦截器</h1><h5 id="一、路由守卫"><a href="#一、路由守卫" class="headerlink" title="一、路由守卫"></a>一、路由守卫</h5><p>在做项目时, 我们总是会判断一个用户有没有登录(例如: 当用户没有登录的时候，跳转到登录页面，已经登录的时候，不能跳转到登录页，除非后台token失效), 要实现这个功能的话, 就需要路由守卫来做.</p><pre><code class="js">1 // 配置全局的vue路由拦截器, 导航守卫(路由守卫)2 router.beforeEach((to,from,next) =&gt; &#123;3  console.log(to);  // 可以看出路由的去向4  console.log(from);  // 可以看出从哪个路由跳转而来5  const token = sessionStorage.getItem(&#39;token&#39;);  // 获取token6  // 判断 是否是跳转到 某页, 如果是则必须登录才能跳转 7  if (to.path in [&#39;某页&#39;, &#39;某页&#39;] || token) &#123;8      next()  // 放行9    &#125; else &#123;10      alert(&#39;没有登陆, 不能操作&#39;);11      next(&#39;/login?back=&#39; + to.fullPath);  //跳转到登录页(带参数), path不能带参数, fullpath可以带参数12     return  // 打断13    &#125;14  &#125;);</code></pre><h5 id="二、拦截器的作用及分类"><a href="#二、拦截器的作用及分类" class="headerlink" title="二、拦截器的作用及分类"></a>二、拦截器的作用及分类</h5><p>拦截器的作用:</p><pre><code>一般来说，像数据交互之类的都要用到不同的身份验证，比如登录 token验证，验证用户是否登录，如果没有登录，该用户就不能操作登录之后的内容.</code></pre><p>拦截器的分类:</p><pre><code>在请求或响应被 then 或 catch 处理前拦截他们，分为请求拦截器和响应拦截器.</code></pre><h5 id="三、请求拦截器和响应拦截器"><a href="#三、请求拦截器和响应拦截器" class="headerlink" title="三、请求拦截器和响应拦截器"></a>三、请求拦截器和响应拦截器</h5><p>   一般在请求拦截器中增加标识token或其他请求配置，在响应拦截器中对统一错误或状态码进行处理(跳转统一页面如登录)</p><p>1、添加请求拦截器</p><p>请求拦截器获取token设置到axios请求头中，如果登录了, 那么自带token发送, 所有请求接口都具有这个功能</p><pre><code class="js">1 // 添加请求拦截器2 axios.interceptors.request.use(config=&gt;&#123;3 // 在发送请求之前做些什么4   return config;5 &#125;, error=&gt; &#123;6    // 对请求错误做些什么7    return Promise.reject8(error);8   &#125;);</code></pre><p>2、添加响应拦截器</p><p>响应拦截器(在响应时会自动做的操作), 响应拦截器一般会对, 响应的错误信息进行处理。</p><pre><code class="js">1 axios.interceptors.response.use(response =&gt; &#123;2  return response;  // 成功信息直接返回&#125;, error =&gt; &#123;3    // 错误信息需要处理4    if (error.request.status === 401) &#123;5      window.location.href = &#39;/&#39;;6    &#125;7   return error8 &#125;);</code></pre><h5 id="四、封装get-post等方法"><a href="#四、封装get-post等方法" class="headerlink" title="四、封装get, post等方法"></a>四、封装get, post等方法</h5><p>可根据封装好的axios，进行封装post,put,get,delete方法</p><p>必要参数:</p><ol><li>url: 请求的url地址</li><li>params: 请求时携带的参数</li><li>headers: 请求时的头部</li></ol><pre><code class="js">1// get方法封装2export function get(url, params, headers) &#123;3  return new Promise((resolve, reject) =&gt; &#123;4    axios.get(url, &#123;params, headers&#125;).then(res =&gt;&#123;5      resolve(res)6    &#125;).catch(err =&gt; &#123;7      reject(err)8    &#125;)9  &#125;)10 &#125;1112 // post方法封装13 export function post(url, params, headers) &#123;14  return new Promise((resolve, reject) =&gt; &#123;15    axios.post(url, params, headers).then(res =&gt;&#123;16      resolve(res)17    &#125;).catch(err =&gt; &#123;18      reject(err)19    &#125;)20  &#125;)21 &#125;2223 // put方法封装24 export function put(url, params, headers) &#123;25  return new Promise((resolve, reject) =&gt; &#123;26    axios.put(url, params, headers).then(res =&gt;&#123;27      resolve(res)28    &#125;).catch(err =&gt; &#123;29      reject(err)30    &#125;)31  &#125;)32 &#125;3334 // delete方法封装35 export function del(url, params, headers) &#123;36   return new Promise((resolve, reject) =&gt; &#123;37    axios.delete(url, &#123;data: params, headers&#125;).then(res =&gt; &#123;38       resolve(res)39    &#125;).catch(err =&gt; &#123;40      reject(err)41    &#125;)42  &#125;)43 &#125;</code></pre><h5 id="五、使用封装方法"><a href="#五、使用封装方法" class="headerlink" title="五、使用封装方法"></a>五、使用封装方法</h5><p>导入</p><pre><code class="js">1 import &#123; get, post, put, del &#125; from &#39;封装axios的js文件&#39;</code></pre><p>登录添加接口</p><pre><code class="js">1 export const signIn = data =&gt; &#123;2  return post(3    &#39;/signIn&#39;,4    data,5   )6 &#125;;</code></pre><p>使用路径传参的接口</p><pre><code class="js">1 export const book = (book_id) =&gt; &#123;2  return get(3    &#39;booksDetail/&#39; + book_id + &#39;/&#39;4   )5 &#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue拦截器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步及异步消费</title>
      <link href="2018/02/12/%E5%BC%82%E6%AD%A5%E6%B6%88%E8%B4%B9/"/>
      <url>2018/02/12/%E5%BC%82%E6%AD%A5%E6%B6%88%E8%B4%B9/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/lake.png" alt="cover"></p><h3 id="一、asyncio"><a href="#一、asyncio" class="headerlink" title="一、asyncio"></a>一、asyncio</h3><p>同步代码:</p><pre><code class="js">import timedef hello():    time.sleep(1)def run():    for i in range(5):        hello()        print(&#39;Hello World:%s&#39; % time.time())  if __name__ == &#39;__main__&#39;:    run()</code></pre><p>输出：</p><pre><code class="js">Hello World:1527595175Hello World:1527595176Hello World:1527595177Hello World:1527595178Hello World:1527595179</code></pre><p>异步代码:</p><pre><code class="js">import timeimport asyncio# 定义异步函数async def hello():    asyncio.sleep(1)    print(&#39;Hello World:%s&#39; % time.time())def run():    for i in range(5):        loop.run_until_complete(hello())loop = asyncio.get_event_loop()if __name__ ==&#39;__main__&#39;:    run()</code></pre><p>输出:</p><pre><code class="js">Hello World:1527595104Hello World:1527595104Hello World:1527595104Hello World:1527595104Hello World:1527595104</code></pre><p>async def 用来定义异步函数，其内部有异步操作。每个线程有一个事件循环，主线程调用asyncio.get_event_loop()时会创建事件循环，你需要把异步的任务丢给这个循环的run_until_complete()方法，事件循环会安排协同程序的执行。</p><h3 id="二、控制任务"><a href="#二、控制任务" class="headerlink" title="二、控制任务"></a>二、控制任务</h3><p>通过asyncio.wait()可以控制多任务</p><p>asyncio.wait()是一个协程，不会阻塞，立即返回，返回的是协程对象。传入的参数是future或协程构成的可迭代对象。最后将返回值传给run_until_complete()加入事件循环</p><pre><code class="js">import asyncioasync def coroutine_example(name):    print(&#39;正在执行:&#39;, name)    await asyncio.sleep(1)    print(&#39;执行完毕:&#39;, name)loop = asyncio.get_event_loop()tasks = [coroutine_example(&#39;nb&#39; + str(i)) for i in range(3)]wait_coro = asyncio.wait(tasks)loop.run_until_complete(wait_coro)loop.close()</code></pre><p>输出结果:</p><pre><code class="js">正在执行:nb_1正在执行:nb_0正在执行:nb_2执行完毕:nb_1执行完毕:nb_0执行完毕:nb_2</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步消费 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
